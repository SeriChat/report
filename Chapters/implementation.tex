\chapter{Implementation} \label{cha:implementation}
%Where the design chapter concerned itself with the overall plan, this
%is where the actual experiment in the form of an implementation is
%taking form.  It is not the purpose of the implementation to fully
%realise the design described in the previous chapter. It is the
%exclusive purpose of the implementation (a subset of the design) to
%either validate or refute the hypotheses put forth in the
%introduction. This, and nothing else. If it does less, you have posed
%questions you are not prepared to answer; if it does more, you should
%be coding less or asking more questions.
%
%If it illustrates core aspects, \eg, the inner working of a particular
%important algorithm or function, code segments are welcome in this
%chapter, as long as they are short, to the point, well-commented and
%-formatted.  It is also a good idea to provide the reader with a
%general overview of the structure of the code, as well as how
%communication between various parts take place.  The complete code (as
%well as your data) should be included separately with your report in
%the form of a zip-file or USB-stick.
%
%Overall, the implementation is the computer scientist's equivalent of
%lab equipment carefully arranged into a experimental setup, and just
%as the validity of an experimental investigation will be judged in
%part on the craftsmanship of the setup, so will the quality of your
%implementation. It is therefore important to clearly communicate how
%your system works, so that the reader may have confidence in your
%evaluation and conclusions.
%System 
This chapter describes the developed prototype of the group chat system according to described design in chapter \ref{cha:design}.
SeriChat is implemented in Java 1.8 and one of the reasons for this choice is to satisfy the goal of being a cross-platform implementation. The second reason is because of TomP2P is implemented in Java. TomP2P is the most up-to-date implementation of the Kademlia infrastructure. \autoref{fig:umlSeriChat} presents the SeriChat architecture and its dependencies to the TomP2P libraries.

\begin{figure}[bth]
	\includegraphics[width=1\linewidth]{gfx/seriChatUML}}
	\caption{SeriChat UML class-diagram}
	{\label{fig:umlSeriChat}
\end{figure}

Description of the different classes...

\section{TomP2P}
TomP2P last stable version, 4.4, has been released at 20th of May, 2013. However, several beta versions has been released subsequently and the newest of them was TomP2P 5.0-Beta8.

In the beginning of this project it was decided to use the last stable version because of the stability but also because of that a big part of the provided documentation, which was very poor, was written for version 4.4. But after coming in contact with the TomP2P developer, Thomas Bocek, he strongly recommended to use the last beta release due to the many new futures and the many bugs fixes which have been done sense version 4.4. He also referred to his GitHub repository where he has a couple of up-to-date examples explaining how to use the last version.

\subsection{Signing key-values}
The key-values in a DHT are in principle overwritable, this is not acceptable by SeriChat groups which is dependable of the availability af the group-keys. However TomP2P has thought about this challenge and provides an entry signing mechanism. When you are putting an entry you can choose to sign the entry by the public-key of the owner. By doing that TomP2P will ensure that the signed entry can only be deleted, updated or overwritten by the author himself. \autoref{lst:signingEntry} shows an how SeriChat let the group owner signs the group-key entry by his pubic-key that is provided by the \textit{keyPair } variable.

\begin{lstlisting}[language=java,frame=tblr,caption={Entry signing by the group owner},label=lst:signingEntry]
ownerPeerDHT.put(groupId).data( new Data( new GroupKey(
	ownerPeerDHT.peerAddress(), keyPair.getPublic()))
	.protectEntry(keyPair)).sign().start().awaitUninterruptibly();
\end{lstlisting}

\subsection{Direct communication}
SeriChat group chat system uses, as explained the chaper \ref{cha:design}, direct communication between the group members. This functionality is provided by TomP2P system's \textit{sendDirect} method. The method accepts a PeerAddress instance which contains the ip-address and the port number. \autoref{lst:sendDirectToRoot} shows how a group member contacts the root directly by using the \textit{sendDirect} method, to get a forwarded to the other group members.
\begin{lstlisting}[language=java,frame=tblr,caption={Sending direct to the root},label=lst:sendDirectToRoot]
SeriEvent seriEvent = new SeriEvent(EventType.FORWARD_MESSAGE, groupName, msgBytes, nickName);
PeerAddress root = group.getRootAddress();
sendingPeerDHT.peer().sendDirect(root).object(seriEvent).start().awaitUninterruptibly();
\end{lstlisting}

\section{Implementing confidentiality}
Java programming language provides two packages to support cryptography, \textit{java.security} package and \textit{javax.crypto} package. Those two packages is used to make the SeriChat confidential. \autoref{lst:cryptoExample} is a code snippet of the \textit{Join} event-handler. The received password is decrypted by a RSA private-key. Then only if the password matches the group password, an AES secret key is encrypted by RSA public-key and replied to the requester.
\begin{lstlisting}[language=java,frame=tblr,caption={Example of \textit{java.security} and \textit{javax.crypto} usage},label=lst:cryptoExample]
cipher = Cipher.getInstance("RSA");
cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
String pass = new String(cipher.doFinal(event.getPassword()));
if (group.getPassword().equals(pass)) {
cipher.init(Cipher.ENCRYPT_MODE, event.getPublicKey());
...
return cipher.doFinal(group.getGrpAESKey().getEncoded());
}
\end{lstlisting}

\section{Fault-tolerance}
The fault-tolerance design described in chapter \ref{cha:design} was not implemented during to some time constraints in the project.
